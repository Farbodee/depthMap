//Import SDK and Framework namespaces
using Rhino;
using Rhino.Geometry;
using Rhino.Collections;

using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Types;

using GH_IO;
using GH_IO.Serialization;

using System;
using System.IO;
using System.Xml;
using System.Xml.Linq;
using System.Linq;
using System.Data;
using System.Drawing;
using System.Reflection;
using System.Collections;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Runtime.InteropServices;



//Code generated by Grasshopper(R) (except for RunScript() content and Additional content)
//Copyright (C) 2013 - Robert McNeel & Associates
[System.Runtime.CompilerServices.CompilerGenerated()]
public class Script_Instance : GH_ScriptInstance //IGH_ScriptInstance
{
#region Members
  /// <summary>List of error messages. Do not modify this list directly.</summary>
  private List<string> __err = new List<string>();

  /// <summary>List of print messages. Do not modify this list directly, use the Print() and Reflect() functions instead.</summary>
  private List<string> __out = new List<string>();

  /// <summary>Represents the current Rhino document.</summary>
  private RhinoDoc doc = RhinoDoc.ActiveDoc;

  /// <summary>Represents the Script component which maintains this script.</summary>
  private IGH_ActiveObject owner;

  /// <summary>Represents the number of times that RunScript has been called within this solution.</summary
  private int runCount;
#endregion

#region Utility functions
  /// <summary>Print a String to the [Out] Parameter of the Script component.</summary>
  /// <param name="text">String to print.</param>
  private void Print(string text)
  {
    __out.Add(text);
  }

  /// <summary>Print a formatted String to the [Out] Parameter of the Script component.</summary>
  /// <param name="format">String format.</param>
  /// <param name="args">Formatting parameters.</param>
  private void Print(string format, params object[] args)
  {
    __out.Add(string.Format(format, args));
  }

  /// <summary>Print useful information about an object instance to the [Out] Parameter of the Script component. </summary>
  /// <param name="obj">Object instance to parse.</param>
  private void Reflect(object obj)
  {
    __out.Add(GH_ScriptComponentUtilities.ReflectType_CS(obj));
  }

  /// <summary>Print the signatures of all the overloads of a specific method to the [Out] Parameter of the Script component. </summary>
  /// <param name="obj">Object instance to parse.</param>
  private void Reflect(object obj, string method_name)
  {
    __out.Add(GH_ScriptComponentUtilities.ReflectType_CS(obj, method_name));
  }
#endregion

  /// <summary>
  /// This procedure contains the user code. Input parameters are provided as regular arguments,
  /// Output parameters as ref arguments. You don't have to assign output parameters,
  /// they will be null by default.
  /// </summary>
  //Gets a list of curves and a another List
  private void RunScript(List<Curve> C, List<Curve> A, ref object D)
  {
    List<Curve> LL = new List<Curve>(A);
    List<int> depthList = new List<int>();

    foreach (Curve crv in C)
    {
      int d = CalculateDepth(crv, LL);
      //Curve crv is counted as 1, subtract this.
      depthList.Add(d - 1);
    }

    D = depthList;
  }

  //<Custom additional code> 
  //Calculates the Depth for each curve on a list of Curves
  private int CalculateDepth(Curve x, List<Curve> y)
  {
    foreach (Curve crv in y)
    {
      crv.SetUserString("D", "nil");
    }

    int depth = 0;

    Queue<Curve> Q = new Queue<Curve>();
    int d = 0;
    x.SetUserString("D", d.ToString());
    Q.Enqueue(x);

    while (Q.Count > 0)
    {
      Curve c = Q.Dequeue();
      int val = Convert.ToInt32(c.GetUserString("D"));
      depth = depth + val;
      Print(depth.ToString());

      List<Curve> connected = FindIntersectingCurves(c, y);
      foreach (Curve crv in connected)
      {
        if (c.GetUserString("D") == "nil")
        {
          d = val + 1;
          crv.SetUserString("D", d.ToString());
          Q.Enqueue(crv);
        }
      }
    }

    return depth;
  }

  private List<Curve> FindIntersectingCurves(Curve x, List<Curve> y)
  {
    Rhino.Geometry.Intersect.CurveIntersections ci;

    List<Curve> intersecting = new List<Curve>();

    foreach (Curve c in y)
    {
      ci = Rhino.Geometry.Intersect.Intersection.CurveCurve(x, c, 0.001, 0.001);
      if (ci.Count > 0) {
        intersecting.Add(c);
      }
    }
    return intersecting;
  }
  //</Custom additional code> 

}